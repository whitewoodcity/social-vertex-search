{
  "type": "publication",
  "subtype": "article",
  "titleImgLink": "",
  "id": "zhaoce",
  "date": "2019-07-03",
  "time": "05:53:11",
  "title": "vert.x-web的源码解析",
  "authorNickname": "lileihanmeimei",
  "content": "本来应该要写的是eventbus的源码分析的，但是Vert.x中国用户组（群号：515203212）的小伙伴们好像对vert.x-web深入了解的需求更大一些。所以就先分析vert.x-web的实现原理吧。 \n分析完之后发现篇幅较长，请耐心看完。\n如果哪里有写的不好的话，或者不好理解的地方，欢迎在评论区提出来，谢谢。\nvert.x-web主要的功能是路由，还有常用的http相关工具（例如：BodyHandler，SessionHandler）。 本文主要围绕vert.x-web是如何实现路由来展开分析。\n\nvert.x-web最主要的是3个类： Router， Route，RoutingContext。\n\n本文分为以下几部分展开分析：\n\nRouter的api接口和实现类RouterImpl\nRoute的api接口和实现类RouteImpl\nRoutingContext的api接口和实现类RoutingContextImpl\n路由过程\n一.  先来看Router部分。\n\nRouter其实就是Route的容器， 里面装载了全部的Route。当request到来时，通过Router匹配容器里的多个Route。Router把路由的工作丢给RoutingContext做了。\n\nRouter相关的api基本都是创建Route（路由点）的。\n\n例如，route()，get(), get(path),  还有创建正则请求路径的Route等等。\n\n除了这些说些比较重要的。\n\npublic interface Router {\n   //省略若干代码...\n  //路由的入口方法。request进来之后，匹配对应的Route\n  void accept(HttpServerRequest request);\n  \n  //在当前router中，挂载子router。\n  Router mountSubRouter(String mountPoint, Router subRouter);\n  \n  //为当前router设置异常处理器\n  Router exceptionHandler(@Nullable Handler<Throwable> exceptionHandler);\n  \n  //这两个方法是用在子router，不能直接调用。\n  void handleContext(RoutingContext context);\n  void handleFailure(RoutingContext context);\n}\n接着看看RouterImpl实现。\n\npublic class RouterImpl implements Router {\n  //省略若干代码...\n  private final Vertx vertx;\n  //存储Route用的是skiplist，相比于List，时间复杂度从O(n)降低到O(lgn)。\n  //并且用的是线程安全的skiplist\n  //routeComparator是排序比较器。\n  private final Set<RouteImpl> routes = new ConcurrentSkipListSet<>(routeComparator);\n  //用于route的序号，保证route在routes的顺序。\n  //排序前面的route的order比较小。\n  private final AtomicInteger orderSequence = new AtomicInteger();\n  //异常处理器，待会分析该异常处理器的调用处。\n  private Handler<Throwable> exceptionHandler;\n\n  public RouterImpl(Vertx vertx) {\n    this.vertx = vertx;\n  } \n  //随便放出点创建route的代码。此时并未将route加入routes容器中，\n  //而是为route设置handler时才加到routes容器，稍后分析\n  public Route route(HttpMethod method, String path) {\n    return new RouteImpl(this, orderSequence.getAndIncrement(), method, path);\n  }\n  public Route route(String path) {\n    return new RouteImpl(this, orderSequence.getAndIncrement(), path);\n  }\n  \n  public void accept(HttpServerRequest request) {\n    //...\n    //请求委托为RoutingContext，由RoutingContext来实现路由。\n    //这里稍后解释，只需要记住accept方法是路由的入口方法。\n    new RoutingContextImpl(null, this, request, routes).next();\n  }\n\n  //分析挂载，所谓的挂载就是把一个有多个子Route的容器Router放到另一个Router（主router）\n  //mountPoint,挂载点，\n  public Router mountSubRouter(String mountPoint, Router subRouter) {\n    //挂载点的路径必须是确定的，不能用通配符和模式匹配\n    if (mountPoint.endsWith('*')) {\n      throw new IllegalArgumentException('Don't include * when mounting subrouter');\n    }\n    if (mountPoint.contains(':')) {\n      throw new IllegalArgumentException('Can't use patterns in subrouter mounts');\n    }\n    //这里就是创建route，然后request达到handler时，转交给subRouter的handleContext。\n    route(mountPoint + '*').handler(subRouter::handleContext)\n                           .failureHandler(subRouter::handleFailure);\n    return this;\n  }\n\n\n  public void handleContext(RoutingContext ctx) {\n    //这里创建一个新的RoutingContext，并且把原来的routingContext包装进去，\n    //还有子router(subRouter)的routes也传进去，然后调用next()在subRouter中路由。\n    new RoutingContextWrapper(getAndCheckRoutePath(ctx), ctx.request(), routes, ctx)\n          .next();\n  }\n  public void handleFailure(RoutingContext ctx) {\n    new RoutingContextWrapper(getAndCheckRoutePath(ctx), ctx.request(), routes, ctx)\n     .next();\n  }\n//getAndCheckRoutePath获取挂载路径\n private String getAndCheckRoutePath(RoutingContext ctx) {\n    //currentRoute的路径只有挂载路径，在mountSubRouter方法中可以看的出来。\n    Route currentRoute = ctx.currentRoute();\n    String path = currentRoute.getPath();\n    return path;\n  }\n}\n先大体看看RouterImpl实现过程，看完RoutingContext和Route再回头来看看Router。\n\n再扯扯subRouter的作用。\n\n如果把所有的route都放在一个Router中，当前功能点多的时候，可能就会有好几百个Route。那么请求路由到排在后面Route时，整个路由的开销可能会比较大点。\n\n使用subRouter，可以把同个模块的功能放到一个subRouter下面。\n\n例如： 用户添加，修改，删除，新增等等。\n\n//示例代码\nRouter mainRouter = Router.router(vertx);\nRouter userRouter = Router.router(vertx);\nuserRouter.get('/:userId')...\nuserRouter.post()...\nuserRouter.delete('/:userId')...\nuserRouter.put('/:userId')...\n//挂载到主router上\nmainRouter .mountSubRouter('/user', userRouter);\n//其他模块亦是如此, 最后就是mainRouter挂载了多个功能模块的subRouter\n//当前subRouter也还可以继续挂subRouter 一般没必要 二级基本能满足绝大多数情况了\n\n\n二. 接下来分析Route和它的实现类RouteImpl\n\n上面分析我们知道，Route的创建是在Router调用route或get或post等等时创建的。\n\nroute常用的方法一般就是设置一下handler。链式调用的方式\n\nrouter.route().handler(handler);\n\n相关方法也不少，主要就是设置各种http的参数。启动关闭Route（默认是启动的），还有让当前的Route在Router容器里排到最后的last()方法。\n\n其中最重要的也是最复杂的，就是设置请求路径path。\n\npublic interface Route {\n  //省略若干代码...\n //一般不用此方法，直接在创建route的时候设置\n Route path(String path);\n //route的序号，一般就是用Router中的orderSequence累加生成的。\n Route order(int order);\n \n Route last();\n //启用\n Route enable();\n //关闭\n Route disable();\n}\n其他的就是设置一下http参数，这里就不扯犊子了。\n\n接下来看继续分析Route的实现类RouteImpl\n\npublic class RouteImpl implements Route {\n  //tm的，属性还真不少，没事，一个一个说\n\n  //存储当前route的router，实例化时传入\n  private final RouterImpl router;\n  //http请求方法，默认是支持全部\n  private final Set<HttpMethod> methods = new HashSet<>();\n  //媒体类型\n  private final Set<MIMEHeader> consumes = new LinkedHashSet<>();\n  private final Set<MIMEHeader> produces = new LinkedHashSet<>();\n  //请求路径\n  private String path;\n  //在router中的序号，一般在实例化时传入\n  private int order;\n  //启用状态\n  private boolean enabled = true;\n  //handler集合，一个route可以设置多个handler，但必须得手动调用next方法\n  private List<Handler<RoutingContext>> contextHandlers;\n  //failureHandlers\n  private List<Handler<RoutingContext>> failureHandlers;\n  //当前route是否添加到router时的状态\n  private boolean added;\n  //正则\n  private Pattern pattern;\n  //restful路径中的key集合，例如：/user/:userId， userId就会存储到groups中\n  private List<String> groups;\n  //是否正常化的路径。 例如： user/add, 前面少了个/, true时，会在路由匹配时加上/\n  private boolean useNormalisedPath = true;\n  //使用正则路径的groups。跟groups差不多。稍后分析。\n  private Set<String> namedGroupsInRegex = new TreeSet<>();\n  \n  //设置handler\n  public synchronized Route handler(Handler<RoutingContext> contextHandler) {\n    //把handler加到集合中。\n    this.contextHandlers.add(contextHandler);\n    checkAdd();\n    return this;\n  }\n  private void checkAdd() {\n    if (!added) {\n      //把当前route加到router容器中，并且修改added的状态为已加入状态\n      //failureHandler方法也是如此，也是设置handler时才加入到router容器中。\n      //至于为什么这步才加入到router中，就自己猜猜吧，哈哈哈。\n      router.add(this);\n      added = true;\n    }}\n   //设置路径，构造方法中也调用checkPath和setPath方法，这两个方法才是关键。\n   public synchronized Route path(String path) {\n    checkPath(path);\n    setPath(path);\n    return this;\n  }\n  //这里很简单，检查了一下path是否以/开头。\n  private void checkPath(String path) {\n    if (''.equals(path) || path.charAt(0) != '/') {\n      throw new IllegalArgumentException('Path must start with /');\n    }\n  }\n\n  //是否是精确请求路径的标记，true: 请求路径中不包括 : 和 *\n  private boolean exactPath;\n\n  private void setPath(String path) {\n    //包含：即restful方式的请求， 那么创建正则。\n    if (path.indexOf(':') != -1) {\n      createPatternRegex(path);\n      this.path = path;\n    } else {\n      //不是以*结尾，那么就是精确匹配了\n      if (path.charAt(path.length() - 1) != '*') {\n        exactPath = true;\n        this.path = path;\n      } else {\n        //这里多说一句，/user/*/add*/name, 像这种是没用的。\n        exactPath = false;\n        //把*去掉，非精确匹配，那么请求时的路径是以path开头就能匹配了\n        this.path = path.substring(0, path.length() - 1);\n      }}}\n\n  //凌晨2:30点，先睡了，身体要紧。\n  //接下看看怎么创建restful模式的正则\n\n  //该正则的作用转义()$.这四个字符，即在字符前面加\\n  private static final Pattern RE_OPERATORS_NO_STAR = \n         Pattern.compile('([\\(\\)\\$\\+\\.])');\n  private void createPatternRegex(String path) {\n    path = RE_OPERATORS_NO_STAR.matcher(path).replaceAll('\\\\$1');\n    //以*结尾的话，将*换成.*  即以任意字符结尾。 \n    if (path.charAt(path.length() - 1) == '*') {\n      path = path.substring(0, path.length() - 1) + '.*';\n    }\n    举例路径： /user/:userId/:name 那么下面的正则将会匹配到userId和name\n    //扫描路径中以:开头的字符串。\n    Matcher m = Pattern.compile(':([A-Za-z][A-Za-z0-9_]*)').matcher(path);\n    StringBuffer sb = new StringBuffer();\n    //存储路径的key \n    groups = new ArrayList<>();\n    int index = 0;\n    //关于正则的知识了，就是path的匹配的值替换一下加到sb中。\n    while (m.find()) {\n      String param = 'p' + index;\n      String group = m.group().substring(1);\n      if (groups.contains(group)) {\n        throw new IllegalArgumentException('Cannot use identifier ' + group + ' more than once in pattern string');\n      }\n      m.appendReplacement(sb, '(?<' + param + '>[^/]+)');\n      //把'userId', 'name', 加到groups, groups在匹配Route的时候用\n      groups.add(group);\n      index++;\n    }\n    m.appendTail(sb);\n    path = sb.toString();\n    //以举例路径为例， 此时path=/user/(?<p0>[^/]+)/(?<p1>[^/]+)\n    //这里我不懂路径为什么要变成这样，但是并不影响分析。懂的朋友麻烦请教一下。\n    //最后以path作为regex进行编译正则，pattern在匹配Route的时候使用。\n    pattern = Pattern.compile(path);\n  }\n\n //先分析匹配route的方法，待会再RoutingContext\n  synchronized boolean matches(RoutingContextImplBase context, \n         String mountPoint, boolean failure) {\n    //failure是通过调用RoutingContext的fail方法设置。\n    //如果当前的RoutingContext的状态是失败的，且当前Route的failureHandler已经超过index了\n    //如果当前的RoutingContext的状态是正常的，且当前Route的handler已经超过index了\n    //那么匹配失败\n    if (failure && !hasNextFailureHandler(context) || \n           !failure && !hasNextContextHandler(context)) {\n      return false;\n    }\n    //未启用， 匹配失败\n    if (!enabled) {\n      return false;\n    }\n    HttpServerRequest request = context.request();\n    //设置了请求方法，但是请求的方法不包括在设置的请求方法中，匹配失败。\n    if (!methods.isEmpty() && !methods.contains(request.method())) {\n      return false;\n    }\n    //常规路径匹配，即非正则匹配。pathMatches（下面有分析）返回false的话，匹配失败。\n    if (path != null && pattern == null && !pathMatches(mountPoint, context)) {\n      return false;\n    }\n    //正则路径\n    if (pattern != null) {\n      String path = useNormalisedPath ? Utils.normalizePath(context.request().path()) : context.request().path();\n      //去掉挂载路径， 正则的路径都是以route中的path来匹配的。\n      if (mountPoint != null) {\n        path = path.substring(mountPoint.length());\n      }\n      Matcher m = pattern.matcher(path);\n      if (m.matches()) {\n        if (m.groupCount() > 0) {\n          if (groups != null) {\n            for (int i = 0; i < groups.size(); i++) {\n              /取出setPath时，添加到groups中的key\n              final String k = groups.get(i);\n              String undecodedValue;\n              // We try to take value in three ways:\n              // 1. group name of type p0, p1, pN (most frequent and used by vertx params)\n              // 2. group name inside the regex\n              // 3. No group name\n              try {\n                //取出路径中的值，按照上述的方式去\n                undecodedValue = m.group('p' + i);\n              } catch (IllegalArgumentException e) {\n                try {\n                  undecodedValue = m.group(k);\n                } catch (IllegalArgumentException e1) {\n                  // Groups starts from 1 (0 group is total match)\n                  undecodedValue = m.group(i + 1);\n                }\n              }\n              //group取出来的值作为key, 从path中取出来的值作为value，添加到\n              //RoutingContext的PathParams中（其中就是HashMap）\n              addPathParam(context, k, undecodedValue);\n            }\n          } else {\n           //由于篇幅有限，关于正则路径的就不展开分析了。\n          } \n    //省略若干代码...\n    return true;\n    }\n \n  //匹配路径\n  private boolean pathMatches(String mountPoint, RoutingContext ctx) {\n    String thePath = mountPoint == null ? path : mountPoint + path;\n    String requestPath;\n    if (useNormalisedPath) { //对请求路径做一些处理\n      requestPath = Utils.normalizePath(ctx.request().path());\n    } else {\n      requestPath = ctx.request().path();\n      if (requestPath == null) {\n        requestPath = '/';\n      }\n    }\n    if (exactPath) {\n      //精准匹配，如果路径后面有/，先移除，然后调用\n      return pathMatchesExact(requestPath, thePath);\n    } else {\n      //非精准匹配，\n      if (thePath.endsWith('/') && requestPath.equals(removeTrailing(thePath))) {\n        //进入这个if分支的话， 当初设置path时， /xxx/xxx/* 这样类型的。\n        //如果请求路径刚好是 /xxx/xxx时，有这个if分支才能匹配成功\n        return true;\n      }\n      //只要请求的路径以route中设置的path开头就算匹配成功。\n      return requestPath.startsWith(thePath);\n    }\n  }\n\n}\nRouteImpl涉及到的代码比较多， 代码也比较核心，所以进行长篇幅的分析。\n\n先总结的一下Route的重点。\n\nhandler是保存到contextHandlers的ArrayList中，failureHandler保存到failureHandlers的ArrayList中。\nRouteImpl添加到Router容器中时设置handler或failureHandler的时候。\nroute的path设置过程和route匹配过程。（敲黑板）\n\n\n三. 接下来来分析RoutingContext\n\nRoutingContext接口涉及到的接口很多，所以挑比较重要的来分析。\n\nRoutingContext，顾名思义，路由上下文嘛， 就是保存路由整个过程的一些信息，辅助路由。\n\npublic interface RoutingContext {\n\n//匹配下一个route\nvoid next();\n\n//设置当前路由状态为失败的，并重新route找下一个失败的route或者当前route的failureHandler\nvoid fail(int statusCode);\nvoid fail(Throwable throwable);\n\n//往RoutingContext存取，移除数据\nRoutingContext put(String key, Object obj);\n<T> T get(String key);\n<T> T remove(String key);\n//获取RoutingContext全部数据\nMap<String, Object> data();\n\n//获取请求体\nString getBodyAsJson();\n//getBodyAsXXX等等\n\n//重新route，相当于servlet中的forward\nvoid reroute(HttpMethod method, String path);\n\n//restful模式中的路径参数 例： /user/:userId/:name， userId和name\nMap<String, String> pathParams();\nString pathParam(String name);\n\n//请求路径的参数。例如：/user?name=wang007&age=18&hobby=girl\nMultiMap queryParams();\nList<String> queryParam(String query);\n}\n其他的比较简单或者比较很少的就不说了，还有例如Session，Cookie等这些可以另起一个章节来说。\n\nRoutingContext在每次请求来到时创建，在Router的accept方法可以看出来。\n\n接下来分析RoutingContext实现类中的属性\n\npublic abstract class RoutingContextImplBase implements RoutingContext {\n  //route容器，Router中传入\n  private final Set<RouteImpl> routes;\n  //挂载点。 默认是null。\n  protected final String mountPoint;\n \n  protected final HttpServerRequest request;\n  //从routes创建的迭代器\n  protected Iterator<RouteImpl> iter;\n  //当前匹配上route  这个会变的 下个route匹配上的 currentRoute就变成下一个route\n  protected RouteImpl currentRoute;\n  //当前的handler索引。 当匹配上下一个route时，索引重计（设为0）\n  protected AtomicInteger currentRouteNextHandlerIndex;\n  protected AtomicInteger currentRouteNextFailureHandlerIndex;\n  //看下构造方法中创建的属性\n  protected RoutingContextImplBase(String mountPoint, HttpServerRequest request, Set<RouteImpl> routes) {\n    this.mountPoint = mountPoint;\n    //用HttpServerRequestWrapper包装，为了用在reroute方法，重设path和method\n    //默认情况下request是不支持重设path和tmethod，所以只能用这种情况偷鸡一下\n    this.request = new HttpServerRequestWrapper(request);\n    this.routes = routes;\n    this.iter = routes.iterator();\n    currentRouteNextHandlerIndex = new AtomicInteger(0);\n    currentRouteNextFailureHandlerIndex = new AtomicInteger(0);\n  }\n}\n\npublic class RoutingContextImpl extends RoutingContextImplBase {\n  private final RouterImpl router;\n\n  //RoutingContext的put，get数据存储处， 数据类型：HashMap\n  private Map<String, Object> data;\n\n  //restful模式中的路径参数,  数据类型：HashMap\n  private Map<String, String> pathParams;\n\n  //路径请求参数， 一key多value  数据类型：CaseInsensitiveHeaders\n  private MultiMap queryParams;\n\n  //用于headersEndHandlers和bodyEndHandlers中key,为了保证顺序。\n  private AtomicInteger handlerSeq = new AtomicInteger();\n  //response响应完headers时调用, 数据类型：TreeMap\n  private Map<Integer, Handler<Void>> headersEndHandlers;\n  //response响应完body时调用, 数据类型：TreeMap\n  private Map<Integer, Handler<Void>> bodyEndHandlers;\n\n  //调用fail方法设置的failure\n  private Throwable failure;\n  //调用fail方法设置的statusCode \n  private int statusCode = -1;\n\n  //常规化路径，\n  private String normalisedPath;\n\n  private String acceptableContentType;\n  private ParsableHeaderValuesContainer parsedHeaders;\n\n  //这些以后另起篇章再分析了\n  private Map<String, Cookie> cookies;\n  private Buffer body;\n  private Set<FileUpload> fileUploads;\n  private Session session;\n  private User user;\n\n  //next方法， 在下面路由过程分析\n  \n  //设置statusCode，并调用doFail方法  fail(Throwable t)也是类似。\n  public void fail(int statusCode) {\n    this.statusCode = statusCode;\n    doFail();\n  }\n  private void doFail() {\n    //重新设置route的迭代器，清空当前currentRoute\n    //iter有记录当前路由到哪个route的作用，从新设置，意味着从头开始重新路由一遍\n    this.iter = router.iterator();\n    currentRoute = null;\n    next();\n  }\n\n  //判断路由状态是否是失败的。\n  public boolean failed() {\n    return failure != null || statusCode != -1;\n  }\n  \n  //重新route   path中不能包含查询参数中 如果包含将会截断\n  public void reroute(HttpMethod method, String path) {\n    int split = path.indexOf('?');\n    if (split == -1) {\n      split = path.indexOf('#');\n    }\n    if (split != -1) {\n      log.warn('Non path segment is not considered: ' + path.substring(split));\n      path = path.substring(0, split);\n    }\n    //设置reroute的method和path\n    ((HttpServerRequestWrapper) request).setMethod(method);\n    ((HttpServerRequestWrapper) request).setPath(path);\n    //清空之前请求的参数\n    request.params().clear();\n    normalisedPath = null;\n    //重置statusCode 失败状态码\n    statusCode = -1;\n    //清空之前请求解析的header\n    response().headers().clear();\n    //清除cookie信息\n    if (cookies != null) {\n      cookies.clear();\n    }\n    if (headersEndHandlers != null) {\n      headersEndHandlers.clear();\n    }\n    if (bodyEndHandlers != null) {\n      bodyEndHandlers.clear();\n    }\n    //重置失败异常\n    failure = null;\n    //从头开始路由，跟doFail方法一样\n    restart();\n  }\n}\nRoutingContext的属性和重要的方法也已经分析完了。\n\n接下来分析路由过程， 本文的重点， 路由通过next方法来完成的。\n\n四.  路由过程\n\n路由的调用过程。\n\n请求通过router.accept方法。\n 然后在accept方法中调用RoutingContext的next方法。这个next方法就是我们可以handler也会经常调用next方法，表示匹配下一个route。\n在next方法中调用RoutingContext一个内部的iterateNext方法\niterateNext方法中逐一调用route的matches方法（前面分析过了），返回true，代表匹配成功，就不再继续匹配了。除非你再手动调用RoutingContext的next方法，代表继续匹配下一个route，如果没有匹配上，那么就返回404， 即使你之前成功匹配过route。\n下面就围绕上面说的这几个点来展开分析。\n\npublic void accept(HttpServerRequest request) {\n    //一次请求到来时，创建一个RoutingContext\n    //第一个参数是挂载点 这里没有挂载，所以是null，\n    //第二个参数router 第三个是request请求 第四个是装载route的容器\n    new RoutingContextImpl(null, this, request, routes).next();\n  }\n\nRoutingContext中的next\npublic void next() {\n    //逐一匹配route  false: route容器中全部route都没匹配上 接着就调用checkHandleNoMatch\n    if (!iterateNext()) {\n      checkHandleNoMatch();\n    }\n  }\n  \n//先分析没匹配上怎么处理\n  private void checkHandleNoMatch() {\n  //这个if分支 至少之前是成功匹配过route的\n  //例如在处理handler时发生异常 或者手动调用RoutingContext.fail方法\n    if (failed()) {\n      unhandledFailure(statusCode, failure, router);\n    } else {\n    //这个分支代表的条件\n    // 1. 全部route都未匹配上 \n    //2.或者成功匹配过route 然后调用了RoutingContext.next方法 却没有再匹配上route\n   \n    //这里有个疑问 为什么在router中不提供一个route未匹配上的handler呢(即404) \n    //就这样直接响应出去了\n    //当然解决方法也有，route.last().handler() 即往route容器最后面加一个route \n    //匹配到该route时，则说明之前所有的route都没匹配上 那么就不会进去到这个else分支了。\n      response().setStatusCode(404);\n      if (request().method() == HttpMethod.HEAD) {\n        response().end();\n      } else {\n        response()\n                .putHeader(HttpHeaderNames.CONTENT_TYPE, 'text/html; charset=utf-8')\n                .end(DEFAULT_404);\n      }\n    }\n  }\n\n  //处理failure\n  protected void unhandledFailure(int statusCode, Throwable failure, RouterImpl router) {\n    //获取调用fail方法时设置statuCode\n    int code = statusCode != -1 ? statusCode : 500;\n    if (failure != null) {\n      //如果router有设置exceptionHandler的话 执行exceptionHandler\n      if (router.exceptionHandler() != null) {\n        router.exceptionHandler().handle(failure);\n      } else {\n        log.error('Unexpected exception in route', failure);\n      }\n    }\n    //如果未完成响应 \n    if (!response().ended()) {\n      try {\n        response().setStatusCode(code);\n      } catch (IllegalArgumentException e) {\n        // means that there are invalid chars in the status message\n        response()\n            .setStatusMessage(HttpResponseStatus.valueOf(code).reasonPhrase())\n            .setStatusCode(code);\n      }\n      response().end(response().getStatusMessage());\n    }\n  }\n\n//接着分析上next方法中iterateNext\n  protected boolean iterateNext() {\n    //判断是否是失败状态的路由\n    boolean failed = failed();\n    // route可以设置多个handler和failureHandler\n    // 即用户在handler中调用了next方法，先匹配当前route是否还有handler\n    if (currentRoute != null) {  //当前route不为空 即之前成功匹配过 \n      try {\n        //正常状态的路由，并且还存在下一个handler 那么执行下一个handler\n        if (!failed && currentRoute.hasNextContextHandler(this)) {\n          currentRouteNextHandlerIndex.incrementAndGet();\n          currentRoute.handleContext(this);\n          // 结束匹配\n          return true;\n         //失败状态的路由，并且还存在下一个failureHandler 那么执行下一个failureHandler \n        } else if (failed && currentRoute.hasNextFailureHandler(this)) {\n          currentRouteNextFailureHandlerIndex.incrementAndGet();\n          currentRoute.handleFailure(this);\n          //结束匹配\n          return true;\n        }\n      } catch (Throwable t) {\n        if (!failed) { //正常状态的路由 调用fail方法 从头开始匹配失败状态的route\n          fail(t);\n        } else { //已经是失败状态的路由了 那么直接调用异常处理\n          //上面已经分析过此方法里 \n          unhandledFailure(-1, t, currentRoute.router());\n        }\n        //结束匹配\n        return true;\n      }\n    }\n    //上面没匹配上 有3种情况\n    //1. 还未成功匹配过route\n    //2. 调用了RoutingContext的fail方法\n    //3. 调用了reroute的方法\n    while (iter.hasNext()) { // Search for more handlers\n      RouteImpl route = iter.next();\n      //重置handler的index\n      currentRouteNextHandlerIndex.set(0);\n      currentRouteNextFailureHandlerIndex.set(0);\n      try {\n        //matches方法是比较重要的方法 上面已经重点分析了\n        if (route.matches(this, mountPoint(), failed)) {\n          try {\n            //设置RoutingContext当前route为刚匹配上的route\n            currentRoute = route;  \n            //匹配上route 调用相应的handler或failureHandler          \n            if (failed && currentRoute.hasNextFailureHandler(this)) {\n              currentRouteNextFailureHandlerIndex.incrementAndGet();\n              route.handleFailure(this);\n            } else if (currentRoute.hasNextContextHandler(this)) {\n              currentRouteNextHandlerIndex.incrementAndGet();\n              route.handleContext(this);\n            } else {\n              continue;\n            }\n          } catch (Throwable t) {\n            //这里跟上面的if分支一样  就不逼逼了\n            if (!failed) {\n              fail(t);\n            } else {\n              unhandledFailure(-1, t, route.router());\n            }\n          }\n          return true;\n        }\n      } catch (IllegalArgumentException e) {\n        unhandledFailure(400, e, route.router());\n        return true;\n      }\n    }\n    //while循环结束  匹配失败 调用checkHandleNoMatch\n    return false;\n  }\n至此  vert.x-web基本分析完了。建议上下结合看。因为有些重要的方法提前分析完了\n\n 为了方便大家理解， 我要用我最擅长的蜜汁画画，画个图方便大家理解。\n\n算了，不画了。\n\n\n不只是什么画的画\n再来扯扯subRouter，即挂载路由的实现。\n\nsubRouter也是通过route添加在到router容器中，这个route的path是/mountPoint*  \n\n即以/挂载路径开头的请求路径都会匹配上该route，由route进入到subRouter中。\n\n上面提到subRouter要调用了自身的handleContext或handleFailure方法，\n\n直接看关键代码。\n\npublic void handleContext(RoutingContext ctx) {\n  new RoutingContextWrapper(getAndCheckRoutePath(ctx), ctx.request(), routes, ctx).next();\n}\n\npublic class RoutingContextWrapper extends RoutingContextImplBase {\n  //一开始的RoutingContext 即1级RoutingContext\n  //这个RoutingContextWrapper 属于2级RoutingContext\n  protected final RoutingContext inner;\n  private final String mountPoint;\n\n  public RoutingContextWrapper(String mountPoint, HttpServerRequest request, \nSet<RouteImpl> iter, RoutingContext inner) {\n    super(mountPoint, request, iter);\n    this.inner = inner;\n    //获取最初的RoutingContext的挂载点，默认是null \n    //如果不为null的话，RoutingContextWrapper属于3级RoutingContext\n    String parentMountPoint = inner.mountPoint();\n    if (mountPoint.charAt(mountPoint.length() - 1) == '/') {\n      mountPoint = mountPoint.substring(0, mountPoint.length() - 1);\n    }\n    //拼接挂载点\n    this.mountPoint = parentMountPoint == null ? mountPoint : parentMountPoint + mountPoint;\n  }\n  //再看看RoutingContextWrapper的next方法， 跟RoutingContext差不多\n  public void next() {\n    //匹配逐一subRouter容器内的全部route  跟RoutingContext一样\n    if (!super.iterateNext()) {\n      //匹配失败时，再回到父router继续匹配 这里确实设计的很巧妙\n      //分析一下场景， 当subRouter调用它的容器内的route的handler发生异常时，\n      //而当前subRouter又没有设置关于异常的route\n      //此时又回到了父router。 所以为mainRouter设置一个关于异常的route即可。\n      inner.next();\n    }\n  }\n接着来扯扯大家经常遇到的疑问。\n\n Router如何传到多个Verticle中？\n这个问题很简单， 上片分析过SharedData的LocalMap， 把Router存到LocalMap，然后在其他的Verticle再取出来。\n\n示例代码\n\n    //1. 在verticle1中\n    val localMap1 = sharedData.getLocalMap<String, Wrapper>('router')\n    val router = Router.router(vertx)\n    localMap1['router1'] = Wrapper(router)\n\n    //2. 在verticle2中\n    val localMap2 = sharedData.getLocalMap<String, Wrapper>('router')\n    val wrapper = localMap2['router1']!!\n    val router1 = wrapper.router\n\nclass Wrapper(val router: Router): Shareable\n其实这样传没啥意义， 因为当请求到来时， router还是在调用Router.accept方法所在的线程执行。分析完路由的整个过也没发现有关线程切换的代码吧？ \n\n2. 要想多个请求都全部写在一个HttpServerVerticle很简单，有空扯扯这个吧。（此刻是想快点终结这篇文章了）\n\n总结：\n\n有个重要的问题忘了说， RoutingContext，Router，Route中的很多属性都是延迟初始化的。\n又不知道要总结啥了，我真的是不善于总结的人。\n源码基于vertx-web-3.5.1\n由于平时下班回到家要学习其他的，所以能做到周更就不错了。而且新工作也没有用vert.x，所以平时接触的vert.x就是业余时间自己玩玩了。当然如果深圳有vert.x的工作， 求内推，哈哈哈哈。"
}