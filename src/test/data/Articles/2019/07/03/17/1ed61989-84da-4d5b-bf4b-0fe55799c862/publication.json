{
  "type": "publication",
  "subtype": "article",
  "titleImgLink": "",
  "id": "zhaoce",
  "date": "2019-07-03",
  "time": "05:53:11",
  "title": "vert.x中sharedData源码解析（local模式）",
  "authorNickname": "lileihanmeimei",
  "content": "接着之前vert.x中future的源码分析完之后，继续分析vert.x core中比较重要组件sharedData,\n\n由于sharedData涉及到local模式和cluster模式，涉及到代码比较多，所以本文暂时只对local模式展开深入分析，关系到cluster模式相关类，就简单略过了。后面有时间对cluster模式在深入分析。\n根据sharedData提供的接口，本文分以下几部分来展开分析。\n\nsharedData的接口说明和sharedData的实现类sharedDataImpl相关属性说明。\nAsyncMap的源码分析。\nLock的源码分析。\ncounter的源码分析。\nLocalMap的源码分析。\nsharedData的api和sharedDataImpl\nsharedData的初始化在创建vert.x的构造方法中，就是简单的new了一下并传入vertx实例和clusterManager。\n\nVertxImpl(VertxOptions options, Handler<AsyncResult<Vertx>> resultHandler) {\n    //省略若干代码\n    ...\n    this.sharedData = new SharedDataImpl(this, clusterManager);\n    //local模式的话， clusterManager为null。\n  }\n\n\npublic interface SharedData {\n  //获取集群的map，如果没有集群管理器，将throw exception\n  <K, V> void getClusterWideMap(String name, Handler<AsyncResult<AsyncMap<K, V>>> resultHandler);\n  \n  //获取异步map，如果没有集群管理器，获取的是local模式的异步map\n  <K, V> void getAsyncMap(String name, Handler<AsyncResult<AsyncMap<K, V>>> resultHandler);\n  \n  //获取lock，如果没有集群管理器，获取的是local模式的lock\n  void getLock(String name, Handler<AsyncResult<Lock>> resultHandler);\n\n  //在特定时间内获取lock，如果没有集群管理器，获取的是local模式的lock\n  void getLockWithTimeout(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler);\n\n  //获取counter， 如果没有集群管理器，获取的是local模式的counter\n  void getCounter(String name, Handler<AsyncResult<Counter>> resultHandler);\n  \n  //获取localMap\n  <K, V> LocalMap<K, V> getLocalMap(String name);\n\n}\n可以看到sharedData提供的api非常简洁，不得不说vert.x的api设计很棒。\n\n接着看sharedData的实现类sharedDataImpl\n\npublic class SharedDataImpl implements SharedData {\n  \n  //sharedData是在整个vert.x实例中共享，所以会有并发问题，这里交给了ConcurrentHashMap\n  //来处理并发问题。所以sharedData提供的api可以放心大胆的用。\n  \n  //正在因为存储到ConcurrentHashMap，所以sharedData的数据可以在整个vert.x共享。\n\n  //这里所有ConcurrentHashMap中的数据也是需要线程安全的。\n\n  //获取lock的默认时间 单位：ms\n  private static final long DEFAULT_LOCK_TIMEOUT = 10 * 1000;\n  \n  private final VertxInternal vertx;\n  //集群管理器\n  private final ClusterManager clusterManager;\n  \n  //local模式的AsyncMap存储在localAsyncMaps \n  private final ConcurrentMap<String, LocalAsyncMapImpl<?, ?>> localAsyncMaps = new ConcurrentHashMap<>();\n  \n  //local模式的Lock存储在localLocks\n  private final ConcurrentMap<String, AsynchronousLock> localLocks = new ConcurrentHashMap<>();\n  \n  //local模式的Counter存储在localCounters \n  private final ConcurrentMap<String, Counter> localCounters = new ConcurrentHashMap<>();\n  \n  //localmap存储在localMaps\n  private final ConcurrentMap<String, LocalMap<?, ?>> localMaps = new ConcurrentHashMap<>();\n\n  public SharedDataImpl(VertxInternal vertx, ClusterManager clusterManager) {\n    this.vertx = vertx;\n    this.clusterManager = clusterManager;\n  }\n\n}\n到这一步，sharedData的实现还是很简单的。\n\n接着分析AsyncMap\n\n2.  AsyncMap\n\npublic class SharedDataImpl implements SharedData {\n\npublic <K, V> void getAsyncMap(String name, \n                      Handler<AsyncResult<AsyncMap<K, V>>> resultHandler) {\n    Objects.requireNonNull(name, 'name');\n    Objects.requireNonNull(resultHandler, 'resultHandler');\n    //判断集群管理器是否为null，null：local模式\n    if (clusterManager == null) {\n      //这里委托给内部方法\n      getLocalAsyncMap(name, resultHandler);\n    //cluster模式\n    } else {\n      clusterManager.<K, V>getAsyncMap(name, ar -> {\n        if (ar.succeeded()) {\n          // Wrap it\n          resultHandler.handle(Future.\n                   succeededFuture(new WrappedAsyncMap<K, V>(ar.result())));\n        } else {\n          resultHandler.handle(Future.failedFuture(ar.cause()));\n        }\n      });\n    }\n  }\n\n  private <K, V> void getLocalAsyncMap(String name, \n               Handler<AsyncResult<AsyncMap<K, V>>> resultHandler) {\n    //就是从localAsyncMaps中获取数据\n    //接着来看LocalAsyncMapImpl这个类。\n    LocalAsyncMapImpl<K, V> asyncMap = (LocalAsyncMapImpl<K, V>) localAsyncMaps\n                      .computeIfAbsent(name, n -> new LocalAsyncMapImpl<>(vertx));\n    //WrappedAsyncMap这个类，就是简单包装了一下，就是做了入参的参数校验\n    resultHandler.handle(Future.succeededFuture(new WrappedAsyncMap<>(asyncMap)));\n  }\n}\n\n//AsyncMap的数据储存还是委托为了ConcurrentHashMap\n//不同的是存取map数据通过回调的方式（这里的回调是同步的）\n\n//AsyncMap很重要的一点就是实现有时间期限数据的存储。所以value再进一步存储到Holder中，\n//由holder还完成时间期限的工作。\n\npublic class LocalAsyncMapImpl<K, V> implements AsyncMap<K, V> {\n\n  private final Vertx vertx;\n  //map存储数据\n  private final ConcurrentMap<K, Holder<V>> map;\n\n  public LocalAsyncMapImpl(Vertx vertx) {\n    this.vertx = vertx;\n    map = new ConcurrentHashMap<>();\n  }\n\n //LocalAsyncMapImpl中的内部类\n private static class Holder<V> {\n    final V value;\n\n    //定时器的id\n    final long timerId;\n\n    //Time To Live 生存时间时长\n    final long ttl;\n\n    //设置值时的时间戳， now - timestamp > ttl,则过期\n    final long timestamp;\n    \n    Holder(V value) {\n      Objects.requireNonNull(value);\n      this.value = value;\n      //ttl为0， 则没有设置时间期限\n      timestamp = ttl = timerId = 0;\n    }\n    Holder(V value, long timerId, long ttl, long timestamp) {\n      Objects.requireNonNull(value);\n      if (ttl < 1) {\n        throw new IllegalArgumentException('ttl must be positive: ' + ttl);\n      }\n      this.value = value;\n      this.timerId = timerId;\n      this.ttl = ttl;\n      this.timestamp = timestamp;\n    }\n    \n    //判断是否有设置时间期限的value\n    boolean expires() {\n      return ttl > 0;\n    }\n    \n    //判断是否 没过期。\n    boolean hasNotExpired() {\n      //如果这里没有设置时间期限的话，一直返回true（即没过期）\n      return !expires() ||\n          //如果有设置时间期限的话，（当前的时间戳 - 设置值的时间戳）< ttl时，则没过期\n          MILLISECONDS.convert(System.nanoTime() - timestamp, NANOSECONDS) < ttl;\n    }\n  }\n\n  //没有设置时间期限的put\n  public void put(final K k, final V v, Handler<AsyncResult<Void>> resultHandler) {\n    Holder<V> previous = map.put(k, new Holder<>(v));\n    \n    //上个元素，且上一个元素上有设置时间期限\n    if (previous != null && previous.expires()) {\n      //取消上个元素的定时器\n      vertx.cancelTimer(previous.timerId);\n    }\n    //响应回调\n    resultHandler.handle(Future.succeededFuture());\n  }\n\n  //有设置时间期限的put\n  public void put(K k, V v, long timeout, \n                      Handler<AsyncResult<Void>> completionHandler) {\n    long timestamp = System.nanoTime();\n    //设置定时任务， 用于清除过期数据，调用removeIfExpired方法\n    long timerId = vertx.setTimer(timeout, l -> removeIfExpired(k));\n    //创建holder并put到map中\n    Holder<V> previous = map.put(k, new Holder<>(v, timerId, timeout, timestamp));\n    if (previous != null && previous.expires()) {\n      vertx.cancelTimer(previous.timerId);\n    }\n    //响应回调\n    completionHandler.handle(Future.succeededFuture());\n  }\n  \n  //清除过期数据\n  private void removeIfExpired(K k) {\n    //判断k是否存在，是的话执行后面这个lambda\n    map.computeIfPresent(k, (key, holder) -> holder.hasNotExpired() ? holder : null);\n  }\n  \n //获取数据\n  public void get(final K k, Handler<AsyncResult<V>> resultHandler) {\n    Holder<V> h = map.get(k);\n    //获取到holder之后，判断有没有过期\n    if (h != null && h.hasNotExpired()) {\n      resultHandler.handle(Future.succeededFuture(h.value));\n    } else {\n      resultHandler.handle(Future.succeededFuture());\n    }\n  }\n}\n通过AsyncMap上面的分析，AsyncMap的ttl是通过vert.x的setTimer定时器来完成的。\n\n接着分析Lock\n\n3. Lock\n\npublic class SharedDataImpl implements SharedData {\n  \n public void getLock(String name, Handler<AsyncResult<Lock>> resultHandler) {\n    Objects.requireNonNull(name, 'name');\n    Objects.requireNonNull(resultHandler, 'resultHandler');\n    //获取lock默认时长，10s\n    getLockWithTimeout(name, DEFAULT_LOCK_TIMEOUT, resultHandler);\n  }\n\n  public void getLockWithTimeout(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    Objects.requireNonNull(name, 'name');\n    Objects.requireNonNull(resultHandler, 'resultHandler');\n    Arguments.require(timeout >= 0, 'timeout must be >= 0');\n    if (clusterManager == null) {\n      //local模式\n      getLocalLock(name, timeout, resultHandler);\n    } else {\n      //cluster模式\n      clusterManager.getLockWithTimeout(name, timeout, resultHandler);\n    }\n  }\n  \n  private void getLocalLock(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    //从localLocks获取lock，如果lock不存在，执行后面lambda创建lock。\n    AsynchronousLock lock = localLocks.computeIfAbsent(name, n -> new AsynchronousLock(vertx));\n    //timeout时间期间内获取lock。\n    lock.acquire(timeout, resultHandler);\n  }\n}\n\npublic class AsynchronousLock implements Lock {  \n  private final Vertx vertx;\n  //等待的节点队列，更确切的说法是通知队列。因为这里不会发生阻塞等待\n  private final Queue<LockWaiter> waiters = new LinkedList<>();\n  //代表是否拥有锁\n  private boolean owned;\n  \n  public void acquire(long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    //获取vert.x执行的上下文，一般情况时eventloopContext\n    Context context = vertx.getOrCreateContext();\n    doAcquire(context, timeout, resultHandler);\n  }\n \n  public void doAcquire(Context context, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    //并发问题通过加锁方式解决\n    synchronized (this) {\n      //判断锁是否在用，\n      if (!owned) {\n        //设置当前线程为锁的拥有者\n        owned = true;\n        //获取锁成功，回调通过context来通知\n        lockAcquired(context, resultHandler);\n      } else {\n       //锁已经被其他线程拥有，则加入通知队列中\n        waiters.add(new LockWaiter(this, context, timeout, resultHandler));\n      }\n    }\n  }\n  //重新加入到eventloop执行回调函数\n  private void lockAcquired(Context context, \n                    Handler<AsyncResult<Lock>> resultHandler) {\n    context.runOnContext(v -> resultHandler.handle(Future.succeededFuture(this)));\n  }\n\n //接着分析加入通知队列，看LockWaiter构造方法\n\n  private static class LockWaiter {\n    final AsynchronousLock lock;\n    final Context context;\n    final Handler<AsyncResult<Lock>> resultHandler;\n    //过期标记\n    volatile boolean timedOut;\n    //是否得到过锁的标记\n    volatile boolean acquired;\n\n    LockWaiter(AsynchronousLock lock, Context context, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n      this.lock = lock;\n      this.context = context;\n      this.resultHandler = resultHandler;   \n      if (timeout != Long.MAX_VALUE) {\n        //通过setTimer设置超时\n        context.owner().setTimer(timeout, tid -> timedOut());\n      }\n    }\n\n    void timedOut() {\n      synchronized (lock) {\n        //定时任务触发。设置超时任务到触发期间，都没有获取过锁，\n        if (!acquired) {\n          //超时， timedOut用于release方法中做清除节点操作\n          timedOut = true;\n          //且通知调用者。 稍后再release方法中做清除节点的工作。\n          context.runOnContext(v -> resultHandler.handle(Future.failedFuture(new VertxException('Timed out waiting to get lock'))));\n        }\n      }\n    }\n}\n\n接着分析释放锁和通知等待者\n  public synchronized void release() {\n    //从队列头部开始获取没有timedOut的等待节点\n    LockWaiter waiter = pollWaiters();\n    if (waiter != null) {\n      waiter.acquire(this);\n    } else {\n      //waiter == null， 没有等待节点， 设置owned=false。则锁空闲\n      owned = false;\n    }\n  }\n\n  private LockWaiter pollWaiters() {\n    while (true) {\n      //remove & get， 这里做清除节点的工作。\n      LockWaiter waiter = waiters.poll();\n      if (waiter == null) {\n        return null;\n      } else if (!waiter.timedOut) {\n        return waiter;\n      }\n    }\n  }\n\n  void acquire(AsynchronousLock lock) {\n     //标记当前节点获取锁成功，acquired属性用于上面的timedOut方法\n      acquired = true;\n     //回调通知调用者获取锁成功。\n      lock.lockAcquired(context, resultHandler);\n    }\n  }\n获取Lock的过程，并发部分通过synchronized来解决。这里其实加锁倒不用担心性能问题，因为加锁过程很短。就是往linkedList添加数据。然后异步回调等待通知。不会一直阻塞线程。\n\n只有获得lock的线程才能执行。对了，获得lock执行完之后， 记得release。\n\n相比于ReentrantLock等lock的优点就是不会阻塞线程。\n\n\n\n4. 接着分析计数器Counter\n\n public void getCounter(String name, Handler<AsyncResult<Counter>> resultHandler) {\n    Objects.requireNonNull(name, 'name');\n    Objects.requireNonNull(resultHandler, 'resultHandler');\n    if (clusterManager == null) {\n      //local模式\n      getLocalCounter(name, resultHandler);\n    } else {\n      clusterManager.getCounter(name, resultHandler);\n    }\n  }\n\n  private void getLocalCounter(String name, Handler<AsyncResult<Counter>> resultHandler) {\n    //从sharedData局部变量localCounters中获取counter\n    //如果不存在，执行lambda表达式创建Counter。\n    Counter counter = localCounters.computeIfAbsent(name, n -> new AsynchronousCounter(vertx));\n    //重新加入到context（一般情况是eventloopContext）执行回调函数\n    Context context = vertx.getOrCreateContext();\n    context.runOnContext(v -> resultHandler.handle(Future.succeededFuture(counter)));\n  }\n\n接着看AsynchronousCounter这个类\n//很简单，把计数的功能委托给AtomicLong来实现。\n//而AtomicLong通过自旋+cas+volatile方式还实现线程安全的计数。\n//这里比较简单，就不再多啰嗦了。\npublic class AsynchronousCounter implements Counter {\n  private final VertxInternal vertx;\n  private final AtomicLong counter;\n\n  public AsynchronousCounter(VertxInternal vertx) {\n    this.vertx = vertx;\n    this.counter = new AtomicLong();\n  }\n}\n\n\n5. 最后分析localMap\n\n public <K, V> LocalMap<K, V> getLocalMap(String name) {\n     //从sharedData中的局部变量localMaps获取LocalMap，\n     //如果不存在，执行lambda计算，创建LocalMapImpl\n     return (LocalMap<K, V>) localMaps.computeIfAbsent(name, \n                           n -> new LocalMapImpl<>(n, localMaps));\n  }\n\nclass LocalMapImpl<K, V> implements LocalMap<K, V> {\n  //sharedData中那个局部变量localMaps，用于清除当前LocalMap\n  private final ConcurrentMap<String, LocalMap<?, ?>> maps;\n  //用于从LocalMaps（maps）清除当前local\n  private final String name;\n  //实际存储数据的map\n  private final ConcurrentMap<K, V> map = new ConcurrentHashMap<>();\n\n  LocalMapImpl(String name, ConcurrentMap<String, LocalMap<?, ?>> maps) {\n    this.name = name;\n    this.maps = maps;\n  }\n  //往localmap添加数据时，做参数校验\n  public V put(K key, V value) {\n    checkType(key);\n    checkType(value);\n    return map.put(key, value);\n  }\n\n //从localmap获取数据时，对value进行copy。\n public V get(Object key) {\n    return copyIfRequired(map.get(key));\n  }\n}\n  //包装类,例如Integer等，String本身是immtuable，所以是线程安全的，不用copy\n  static <T> T copyIfRequired(T obj) {\n    if (obj instanceof JsonObject) {\n      return (T)((JsonObject)obj).copy();\n    } else if (obj instanceof JsonArray) {\n      return (T) ((JsonArray) obj).copy();\n    } else if (obj instanceof byte[]) {\n      //Copy it\n      byte[] bytes = (byte[]) obj;\n      byte[] copy = new byte[bytes.length];\n      System.arraycopy(bytes, 0, copy, 0, bytes.length);\n      return (T) copy;\n    } else if (obj instanceof Buffer) {\n      //Copy it\n      return (T) ((Buffer) obj).copy();\n    } else {\n      return obj;\n    }\n  }\n最后来说说localmap中获取数据时做copy操作。即可以保证使用value时的线程安全。\n\n当自己实现Shareable的接口的类放到localmap不会有copy工作，当然线程安全工作就得由自己保证了。\n\n最后说说map中的computeIfxxx方法都是有延迟初始化的作用。\n\n总结：\n\n毛线，好像没啥可总结的。\n如果有写的不好的地方，欢迎指正。\n本文基于vertx.3.5.1\n最近换了个工作，哎， 又干上了spring。vert.x就得业余时间玩玩了。伤心ing...\n\n由于对集群管理器不是很熟悉。下面有可能跳过cluster模式的sharedData的分析，就是到了eventbus的分析。"
}
